<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<title>Exploiting Implicit Beliefs to Resolve Sparse Usage Problem in Usage-based Specification Mining

</title>
<meta charset="iso-8859-1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles/layout.css" type="text/css" media="all">
<link rel="stylesheet" href="styles/mediaqueries.css" type="text/css" media="all">
<script src="scripts/jquery.1.9.0.min.js"></script>
<script src="scripts/jquery-mobilemenu.min.js"></script>
<!--[if lt IE 9]>
<link rel="stylesheet" href="styles/ie.css" type="text/css" media="all">
<script src="scripts/ie/css3-mediaqueries.min.js"></script>
<script src="scripts/ie/ie9.js"></script>
<script src="scripts/ie/html5shiv.min.js"></script>
<![endif]-->
</head>
<body>
<div class="wrapper row1">
  <header id="header" class="clear">
    <div id="hgroup">
      <h1><a href="#">Exploiting Implicit Beliefs to Resolve Sparse Usage Problem in Usage-based Specification Mining</a></h1>
    </div>
  </header>
</div>
<!-- ################################################################################################ -->
<div class="wrapper row2">
  <nav id="topnav">
    <ul class="clear">
      <li class="active first"><a href="index.html">Main</a></li>
      <li><a class="drop" href="data.html">Collected Data</a>
        <ul>
          <li><a href="data.html#data">Client Code Corpus</a></li>
          <li><a href="ground_truth.xlsx">Ground-truth of Preconditions</a></li>
        </ul>
      </li>
      <li><a class="drop">Result Analysis</a>
        <ul>
          <li><a href="accuracy.html">Accuracy</a></li>
          <li><a class="drop" href="characteristics.html">Characteristics of Mined Preconditions</a>
            <ul>
              <li><a href="characteristics.html#correct">Correctly Mined Preconditions</a></li>
              <li><a href="characteristics.html#incorrect">Incorrectly Mined Preconditions</a></li>
              <li><a href="characteristics.html#missing">Missing Preconditions</a></li>
            </ul>
          </li>
          <li><a class="drop" href="components.html">Effectiveness of Single Components</a>
            <ul>
              <li><a href="components.html#ccl">Count Controlled Loop (CCL)</a></li>
              <li><a href="components.html#oic">Object Instance Creation (OIC)</a></li>
              <li><a href="components.html#tc">Type Comparison (TC)</a></li>
              <li><a href="components.html#nd">Null Derefrence (ND)</a></li>
              <li><a href="components.html#sce">Short Circuit Evaluation (SCE)</a></li>
              <li><a href="components.html#le">Local Exception (LE)</a></li>
              <li><a href="components.html#cfa">1-Level Control Flow Analysis (1-CFA)</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a class="drop" href="figurestables.html">Figures and Tables</a>
        <ul>
          <li><a href="figurestables.html#dataset">Figure 9. Dataset</a></li>
          <li><a href="figurestables.html#accuracy">Figure 10. Accuracy</a></li>
          <li><a href="figurestables.html#correct">Table 1. Correctly-mined preconditions</a></li>
          <li><a href="figurestables.html#incorrect">Table 2. Incorrectly-mined preconditions</a></li>
          <li><a href="figurestables.html#missing">Table 3. Missing preconditions</a></li>
          <li><a href="figurestables.html#components">Table 4. Improvement for single components</a></li>
          <li><a href="figurestables.html#ccl">Figure 11. Accuracy of Count Controlled Loop (CCL)</a></li>
          <li><a href="figurestables.html#oic">Figure 12. Accuracy of Object Instance Creation (OIC)</a></li>
          <li><a href="figurestables.html#tc">Figure 13. Accuracy of Type Comparison (TC)</a></li>
          <li><a href="figurestables.html#nd">Figure 14. Accuracy of Null Dereference (ND)</a></li>
          <li><a href="figurestables.html#sce">Figure 15. Accuracy of Short Circuit Evaluation (SCE)</a></li>
          <li><a href="figurestables.html#le">Figure 16. Improvement in precision of Local Exception (LE)</a></li>
          <li><a href="figurestables.html#cfa">Figure 17. Accuracy of 1-Level Control Flow Analysis (1-CFA)</a></li>
        </ul>
      </li>
    </ul>
  </nav>
</div>
<!-- content -->
<div class="wrapper row3">
  <div id="container">
    <!-- ################################################################################################ -->
    <div class="full_width clear">
    	<p>We studied the characteristics of the preconditions that were correctly-mined, incorrectly-mined and missing from our approach.</p>
      <p><a name="cmp"><h2>Correctly Mined Preconditions</h2></a>
		  For the APIs in our dataset, correctly mined preconditions falls into three categories: null comparison, primitive comparison and method invocation. The first one contains simple preconditions comparing arguments with null such as ARG!=null. The preconditions in the second category contains arguments of primitive types comparing to constants or other primitive arguments such as ARG1&ge;0 and ARG1&le;ARG2. The last one containing method calls, on receivers such as !Receiver.hasNext() or on arguments such as !ARG.isEmpty() or on both. Table 1 shows the numbers of preconditions for each category correctly mined from the base approach and the additional ones from our approach using implicit beliefs. The numbers in parentheses are the percentages over all expected preconditions in the corresponding category.
      <image src="figures/table1.png" /></p>
      The result shows that our approach could mine additional preconditions that were missed by the base one in all three categories. However, the improvement was mainly in simpler preconditions which involve comparing arguments against null or comparing between primitive values. This is due to the fact that the code elements mostly contain implicit beliefs for inferring those kinds of preconditions. Three in six of the implemented components, Object Instance Creation (OIC), Type Comparison (TC) and Null Dereference (ND), look for non-null property of API components. Our tool mined these preconditions for the chosen libraries (Table 1) when related implicit belief is present. Count-controlled Loop (CCL) component only infers the conditions checking the index/counter of the loop against its bounds. Local Exception (LE) could only remove incorrectly-mined preconditions but not add correctly-mined ones. Short Circuit Evaluation (SCE) is the only component that could infer new complex preconditions involving multiple API components.
    </div>
    <!-- ################################################################################################ -->
  </div>
</div>
<!-- Footer -->
<div class="wrapper row4">
  <footer id="footer" class="clear">
    <p class="fl_left">Copyright &copy; 2013 - All Rights Reserved</p>
    <p class="fl_right">Template by <a href="http://www.os-templates.com/" title="Free Website Templates">OS Templates</a></p>
  </footer>
</div>
</body>
</html>
